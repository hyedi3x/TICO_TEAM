# Blockly
```
npm install blockly(blockly 패키지 설치 명령어)
```
<br/>

# package.json
```
package.json에 이렇게 들어가면 성공
"blockly": "^11.2.2"
```
<br/>

## 사용자 정의 블록 속성
- Blockly에서 커스텀(사용자 정의) 블록을 만들 때는 JSON 또는 JavaScript 형식으로 사용하여 각 블록의 속성을 적용해야 합니다.
- 하지만 비교 결과 JSON이 좀 더 직관적이고 알기 쉬워서 JSON 형식으로 커스텀 블록을 정의하는 방식으로 했습니다.
<br/>

### 1. type
- 블록의 고유한 타입을 정의합니다. 
- 이 값은 블록을 식별하는 데 사용됩니다.
<br/>

### 2. message0(오타아님)
- 블록의 메시지 텍스트입니다. 
- 사용자가 해당 블록을 사용할 때 나타나는 텍스트를 정의합니다.
- 필요한 경우 변수나 입력값을 포함할 수 있습니다.
- 설정을 할 때 %1부터 시작합니다.(그럼 그 다음에는 %2로 설정합니다.)
<br/>

### 3. args0(오타아님)
- 블록에 포함된 입력 요소들을 정의합니다.
- 각 항목은 type, name, value 등의 속성으로 세부 정의가 가능합니다.
- 세부 정의를 다양한 속성으로 정의를 해줘서 그 정의한 것이 message 속성에 순서대로 들어갑니다
<br/>

### 4. output
- 블록이 반환하는 값의 유형을 정의합니다.
- 예를 들어, Number나 Boolean 등이 될 수 있습니다.
<br/>

### 5. colour
- 블록의 색상을 정의합니다. 
- 색상은 블록의 카테고리와 관련이 있으며, 각 카테고리에 따라 다른 색을 지정할 수 있습니다.
- hex로 색상을 직접 설정해도 되고 정수를 입력하면 hue가 적용되서 블록의 색상이 변합니다.
<br/>

### 6. tooltip
- 블록에 대한 툴팁 텍스트입니다.
- 사용자가 마우스를 올렸을 때 나타나는 설명입니다.
- 일종의 도움말이라고 보면 됩니다.
<br/>

### 7. helpUrl
- 사용자가 블록에 대해 더 자세히 알 수 있는 링크를 설정하는 속성입니다.
- 이 속성은 선택적인 속성이라 굳이 쓸 필요는 없습니다.
<br/>

### 8. previousStatement, nextStatement(기능이 똑같아서 같이 설명)
- 블록의 틀을 만들고 정의할 때 연결을 할지 설정합니다.
- previous는 블록 위쪽 연결점, next는 블록 아래쪽 연결점입니다.
- 값을 null로 설정하면 각 연결점에 연결될 블록들의 데이터 타입을 개의치 않고 연결 가능합니다.
- NUMBER로 적용하면 해당 연결점에 있는 건 반환하는 값이 숫자인 블록이나 데이터만 올 수 있습니다.
- 그럼 위아래 연결점이 하나도 없는 상태의 블록을 만들고 싶다면 그냥 이 두개의 속성을 안 쓰면 됩니다.
<br/>

### 9. check
- check에는 타입을 설정합니다.
- 숫자만 오게 하려면 NUMBER, 논리값만 오게 하고 싶으면 Boolean 이런 식으로 설정합니다. 
- 잘못된 타입이 오면 경고를 하거나 입력하는 곳이 붉은색으로 색이 변하면서 경고를 합니다.
<br/>

### 10. align
- 값을 입력할 때 어떤 방향으로 정렬할지 결정합니다.
- args0 속성에서 type을 input_value로 지정하면 블록이 연결이 되고 그 블록안에 값을 입력한 형식으로 나옵니다.
<br/>

### 11. name
- 입력값이 블록에서 어떻게 참조될지를 정의하는 속성입니다.
- name 속성의 값은 어떤 이름으로 설정해도 상관없습니다.(Action이라고 설정하든 A라고 설정하든 그건 상관없습니다)
- 하지만 이 설정한 값을 통해 블록을 사용하고 실행해서 코드가 생성될 때 이 name 속성의 설정값을 참조를 합니다.
- 무슨 뜻이냐면 작업공간의 블록을 실행할 때 해당 프로그램 코드(JS면 JS, 파이썬이면 파이썬)로 변환합니다. 
- 이때 name 속성에 설정한 이름이 고유한 이름 역할을 합니다.
- 자바의 form 태그에서 submit을 할 때 name 속성과 약간 비슷하다고 보시면 됩니다.
<br/>

#### 예시(커스텀 블록 - Blockly에서 제공되지 않는 블록은 직접 디자인을 하고 기능을 다 만들어야합니다.)
- 이 코드를 통해 나타나는 블록은 "소리 재생 %1"이란 메세지로 디자인되는 블록입니다.
- 이런 경우에는 args0 속성을 통해서 %1에 들어갈 메시지가 문자열만 들어가게 되어있습니다.
- 그리고 오른쪽 정렬이고, 위아래 둘다 연결점이 생기는 블록입니다.
```
{
    "type": "play_sound",
    "message0": "소리 재생 %1",
    "args0": [
    {
        "type": "input_value",
        "name": "SOUND",
        "check": "String",
        "align": "RIGHT"
    }
    ],
    "previousStatement": null,
    "nextStatement": null,
    "colour": 160,
    "tooltip": "주어진 소리 파일을 재생합니다.",
    "helpUrl": ""
}
```


#### 예시(커스텀한 블록 기능 설정)

- 블록을 만들고 실행한다고 블록이 동작하지 않습니다. 이런 식으로 아래처럼 기능을 직접 만들어야 합니다.
- Blockly의 경우 기능을 직접 만들 경우 블록을 실행할 때 코드로 변환해서 그 코드를 실행하는 방식으로 만듭니다.

- 이때 블록에 해당하는 기능을 언어로 변환하는데 대표적인 것이 javascript, python입니다.
- 지금 보시면 위 커스텀 부분에서 name 속성으로 설정한 이름 SOUND가 있습니다.

- 그리고 아래 블록 기능 설정한 코드에서도 똑같은 이름을 매개변수로 쓰는 부분이 있습니다.
- 이 경우 똑같은 타입의 블록에 적용한 name 속성의 값이 일치하는 걸 볼 수가 있습니다.

- 그러면 만약 블록을 작업공간에 놓고 문자열을 입력해서 실행을 하면 name 속성의 값이 일치하기 때문에 코드가 제대로 실행이 됩니다.
- 하지만 커스텀을 할 때 "P"로 설정을 했는데, 아래 기능 설정을 하는 부분에서 그대로 "SOUND"로 설정을 하면 해당 name 속성이 일치하지 않게 됩니다.
- 그러면 해당되는 name 속성이 없어서 오류가 나게 됩니다. 그래서 주의해야 합니다.

```
javascriptGenerator.forBlock['play_sound'] = function(block) {
    let soundUrl = javascriptGenerator.valueToCode(block, 'SOUND', javascriptGenerator.ORDER_ATOMIC);
    let code = sound.playSound(soundUrl);
    return code;
};
```

#### 예시(본격적인 블록 실행)
- javascriptGenerator의 workspaceToCode 메서드로 작업공간 안에 있는 모든 블록들이 그 블록들에 해당하는 코드를 모두 변환합니다.
- 그리고 변수에 담아서 그 변수 안에 담긴 코드를 실행을 해서 작동을 합니다.
```
    const code = javascriptGenerator.workspaceToCode(workspace);
```